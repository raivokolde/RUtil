#
a = melt(xMod_13)#
a$X3 = str_replace(a$X2, ".[0-9]*$", "")
attribute = factor(get.var.ncdf(f, "DrugConc"))
unique(c(.3, .4 - .1, .5 - .2, .6 - .3, .7 - .4))
library(grid)#
#
lo = function(rown, coln, cellheight = NA, cellwidth = NA, treeheight_col, treeheight_row, legend,  ...){#
	#
	longest_coln = which.max(nchar(coln))#
	coln_height = unit(1.1, "grobheight", textGrob(coln[longest_coln], rot = 90, gp = gpar(...)))#
	#
	longest_rown = which.max(nchar(rown))#
	rown_width = unit(1.1, "grobwidth", textGrob(rown[longest_rown], gp = gpar(...)))#
	#
	if(!is.na(legend[1])){#
		longest_break = which.max(nchar(as.character(legend)))#
		longest_break = unit(1.1, "grobwidth", textGrob(as.character(legend)[longest_break], gp = gpar(...)))#
		legend_width = unit(12, "bigpts") + longest_break * 1.05#
	}#
	else{#
		legend_width = unit(0, "bigpts")#
	}#
	#
	treeheight_col = unit(treeheight_col, "bigpts")#
	treeheight_row = unit(treeheight_row, "bigpts") #
	#
	#
	if(is.na(cellwidth)){#
		matwidth = unit(1, "npc") - rown_width - legend_width - treeheight_row#
	}#
	else{#
		matwidth = unit(cellwidth * length(coln), "bigpts")#
	}#
	#
	if(is.na(cellheight)){#
		matheight = unit(1, "npc") - coln_height - treeheight_col#
	}#
	else{#
		matheight = unit(cellheight * length(rown), "bigpts")#
	}	#
	#
	#
	pushViewport(viewport(layout = grid.layout(nrow = 3, ncol = 4, widths = unit.c(treeheight_row, matwidth, rown_width, legend_width), heights = unit.c(treeheight_col, matheight, coln_height))))#
}#
#
draw_dendrogram = function(hc, horizontal = T){#
	h = hc$height / max(hc$height) / 1.05#
	m = hc$merge#
	o = hc$order#
	n = length(o)#
#
	m[m > 0] = n + m[m > 0] #
	m[m < 0] = abs(m[m < 0])#
#
	dist = matrix(0, nrow = 2 * n - 1, ncol = 2, dimnames = list(NULL, c("x", "y"))) #
	dist[1:n, 1] = 1 / n / 2 + (1 / n) * (match(1:n, o) - 1)#
#
	for(i in 1:nrow(m)){#
		dist[n + i, 1] = (dist[m[i, 1], 1] + dist[m[i, 2], 1]) / 2#
		dist[n + i, 2] = h[i]#
	}#
	#
	draw_connection = function(x1, x2, y1, y2, y){#
		grid.lines(x = c(x1, x1), y = c(y1, y))#
		grid.lines(x = c(x2, x2), y = c(y2, y))#
		grid.lines(x = c(x1, x2), y = c(y, y))#
	}#
	#
	if(horizontal){#
		for(i in 1:nrow(m)){#
			draw_connection(dist[m[i, 1], 1], dist[m[i, 2], 1], dist[m[i, 1], 2], dist[m[i, 2], 2], h[i])#
		}#
	}#
	#
	else{#
		gr = rectGrob()#
		pushViewport(viewport(height = unit(1, "grobwidth", gr), width = unit(1, "grobheight", gr), angle = 90))#
		for(i in 1:nrow(m)){#
			draw_connection(dist[m[i, 1], 1], dist[m[i, 2], 1], dist[m[i, 1], 2], dist[m[i, 2], 2], h[i])#
		}#
		upViewport()#
	}#
}#
#
draw_matrix = function(matrix){#
	n = nrow(matrix)#
	m = ncol(matrix)#
	x = (1:m)/m - 1/2/m#
	y = (1:n)/n - 1/2/n#
	for(i in 1:m){#
		grid.rect(x = x[i], y = y[1:n], width = 1/m, height = 1/n, gp = gpar(fill = matrix[,i], col = "grey60"))#
	}#
}#
#
draw_colnames = function(coln, ...){#
	m = length(coln)#
	x = (1:m)/m - 1/2/m#
	grid.text(coln, x = x, y = unit(0.96, "npc"), vjust = 0.5, hjust = 0, rot = 270, gp = gpar(...))#
}#
#
draw_rownames = function(rown, ...){#
	n = length(rown)#
	y = (1:n)/n - 1/2/n#
	grid.text(rown, x = unit(0.04, "npc"), y = y, vjust = 0.5, hjust = 0, gp = gpar(...))	#
}#
#
draw_legend = function(col, breaks, legend, ...){#
	height = min(unit(1, "npc"), unit(150, "bigpts"))#
	pushViewport(viewport(height = height))#
	legend_pos = (legend - min(breaks)) / (max(breaks) - min(breaks))#
	breaks = (breaks - min(breaks)) / (max(breaks) - min(breaks))#
	h = breaks[-1] - breaks[-length(breaks)]#
	grid.rect(x = 0, y = breaks[-length(breaks)], width = unit(10, "bigpts"), height = h, hjust = 0, vjust = 0, gp = gpar(fill = col, col = "#
	grid.text(legend, x = unit(12, "bigpts"), y = legend_pos, hjust = 0, gp = gpar(...))#
	upViewport()#
}#
#
#
vplayout = function(x, y){#
	return(viewport(layout.pos.row = x, layout.pos.col = y))#
}#
#
heatmap_motor = function(matrix, cellwidth = NA, cellheight = NA, tree_col = NA, tree_row = NA, treeheight_col, treeheight_row, filename = NA, width = NA, height = NA, breaks, col, legend, ...){#
	grid.newpage()#
	#
	#
	lo(coln = colnames(matrix), rown = rownames(matrix), cellwidth = cellwidth, cellheight = cellheight, treeheight_col = treeheight_col, treeheight_row = treeheight_row, legend = legend, ...)#
	#
	#
	if(!is.na(tree_col[[1]][1])){#
		pushViewport(vplayout(1, 2))#
		draw_dendrogram(tree_col, horizontal = T)#
		upViewport()#
	}#
	#
	#
	if(!is.na(tree_row[[1]][1])){#
		pushViewport(vplayout(2, 1))#
		draw_dendrogram(tree_row, horizontal = F)#
		upViewport()#
	}#
	#
	#
	pushViewport(vplayout(2, 2))#
	draw_matrix(matrix)#
	upViewport()#
	#
	#
	pushViewport(vplayout(3, 2))#
	draw_colnames(colnames(matrix), ...)#
	upViewport()#
	#
	#
	pushViewport(vplayout(2, 3))#
	draw_rownames(rownames(matrix), ...)#
	upViewport()#
	#
	#
	if(!is.na(legend[1])){#
		pushViewport(vplayout(2, 4))#
		draw_legend(col, breaks, legend, ...)#
		upViewport()#
	}#
	#
	pushViewport(vplayout(1:3, 1:4))#
	#
	if(!is.na(filename)){#
		if(is.na(height)){#
			height = convertHeight(unit(0:1, "npc"), "inches", valueOnly = T)[2]#
		}#
		if(is.na(width)){#
			width = convertWidth(unit(0:1, "npc"), "inches", valueOnly = T)[2]#
		}#
		pdf(filename, height = height, width = width)#
		#
		heatmap_motor(matrix, cellwidth, cellheight, tree_col = tree_col, tree_row = tree_row, treeheight_col = treeheight_col, treeheight_row = treeheight_row, breaks = breaks, col = col, legend = legend, file = NA, ...)#
		dev.off()#
	}#
}#
#
generate_breaks = function(x, n){#
	seq(min(x, na.rm = T), max(x, na.rm = T), length.out = n + 1)#
}#
#
scale_vec_colours = function(x, col = rainbow(10), breaks = NA){#
	return(col[as.numeric(cut(x, breaks = breaks, include.lowest = T))])#
}#
#
scale_colours = function(mat, col = rainbow(10), breaks = NA){#
	mat = as.matrix(mat)#
	return(matrix(scale_vec_colours(as.vector(mat), col = col, breaks = breaks), nrow(mat), ncol(mat), dimnames = list(rownames(mat), colnames(mat))))#
}#
#
rheatmap = function(mat, col = colorRampPalette(rev(c("#
	mat = as.matrix(mat)#
	#
	if(cluster_rows){#
		tree_row = hclust(dist(mat))#
		mat = mat[tree_row$order, ]#
	}#
	else{#
		tree_row = NA#
		treeheight_row = 0#
	}#
	#
	if(cluster_cols){#
		tree_col = hclust(dist(t(mat)))#
		mat = mat[, tree_col$order]#
	}#
	else{#
		tree_col = NA#
		treeheight_col = 0#
	}#
	#
	if(legend){#
		legend = grid.pretty(range(as.vector(mat)))#
	}#
	else{#
		legend = NA#
	}#
	#
	breaks = generate_breaks(as.vector(mat), length(col))#
	mat = scale_colours(mat, col = col, breaks = breaks)#
	#
	heatmap_motor(mat, cellwidth = cellwidth, cellheight = cellheight, treeheight_col = treeheight_col, treeheight_row = treeheight_row, tree_col = tree_col, tree_row = tree_row, filename = filename, width = width, height = height, breaks = breaks, col = col, legend = legend,  ...)#
}
package.skeleton(name = "rheatmap")
install(pheatmap)
#
	test = matrix(rnorm(200), 20, 10)#
	test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
	test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
	colnames(test) = paste("Test", 1:10, sep = "")#
	rownames(test) = paste("Gene", 1:20, sep = "")
pheatmap(test, cellwidth = 15, cellheight = 12, cluster_row = FALSE)
pheatmap(test, cellwidth = 15, cellheight = 12, legend = FALSE)
pheatmap(test, cellwidth = 15, cellheight = 12, fontsize = 8, filename = "~/Desktop/test.pdf")
annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2")), Var2 = 1:10)#
	rownames(annotation) = paste("Test", 1:10, sep = "")
#
	Var1 = c("navy", "darkgreen")#
	names(Var1) = c("Class1", "Class2")#
	Var2 = c("lightgreen", "navy")
ann_colors = list(Var1 = Var1, Var2 = Var2)#
#
	pheatmap(test, annotation = annotation, annotation_colors = ann_colors)
test = matrix(rnorm(200), 20, 10)#
	test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] +2#
	test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] -2#
	colnames(test) = paste("Test", 1:10, sep = "")#
	rownames(test) = paste("Gene", 1:20, sep = "")#
#
	#
	pheatmap(test)
test = matrix(rnorm(200), 20, 10)#
	test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] +3#
	test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] -3#
	colnames(test) = paste("Test", 1:10, sep = "")#
	rownames(test) = paste("Gene", 1:20, sep = "")#
#
	#
	pheatmap(test)
test = matrix(rnorm(200), 20, 10)#
	test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] +3#
	test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] +3#
	colnames(test) = paste("Test", 1:10, sep = "")#
	rownames(test) = paste("Gene", 1:20, sep = "")#
#
	#
	pheatmap(test)
test = matrix(rnorm(200), 20, 10)#
	test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] +3#
	test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] +1#
	colnames(test) = paste("Test", 1:10, sep = "")#
	rownames(test) = paste("Gene", 1:20, sep = "")#
#
	#
	pheatmap(test)
test = matrix(rnorm(200), 20, 10)#
	test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] +3#
	test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] +2#
	colnames(test) = paste("Test", 1:10, sep = "")#
	rownames(test) = paste("Gene", 1:20, sep = "")#
#
	#
	pheatmap(test)
pheatmap(test, scale = "row", clustering_distance = "correlation")
pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
pheatmap(test, cluster_row = FALSE)
pheatmap(test, legend = FALSE)
pheatmap(test, cellwidth = 15, cellheight = 12, fontsize = 8, filename = "test.pdf")
#
	annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2")), Var2 = 1:10)#
	rownames(annotation) = paste("Test", 1:10, sep = "")
pheatmap(test, annotation = annotation)
pheatmap(test, annotation = annotation, annotation_legend = FALSE)
#
	Var1 = c("navy", "darkgreen")#
	names(Var1) = c("Class1", "Class2")#
	Var2 = c("lightgreen", "navy")#
#
	ann_colors = list(Var1 = Var1, Var2 = Var2)#
#
	pheatmap(test, annotation = annotation, annotation_colors = ann_colors)
?heatmap
heatmap(test, cellwidth = 15, cellheight = 12)
pheatmap(test, cellwidth = 15, cellheight = 12)
heatmap(test)
pheatmap(test, clustering_method = "single")
pheatmap(test, clustering_method = "average")
pheatmap(test, clustering_method = "average", scale = "row")
pheatmap(test, clustering_method = "single", scale = "row")
annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2"))#
	, Var2 = 1:10)#
	rownames(annotation) = paste("Test", 1:10, sep = "")#
#
	pheatmap(test, annotation = annotation)
annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2"))#
	, Var2 = 1:10)#
	rownames(annotation) = paste("Test", 1:10, sep = "")#
#
	pheatmap(test, annotation = annotation, cluster_row = F)
annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2"))#
	, Var2 = 1:10)#
	rownames(annotation) = paste("Test", 1:10, sep = "")#
#
	pheatmap(test, annotation = annotation, cluster_col = F)
install.packages(pheatmap)
install.packages("MASS")
install.packages("pheatmap")
Reduce
Map
ll = llply(l, function(x){#
	x = sort(x)#
	x = x[x > 0]#
	kvant_x = cumsum(1:length(x) / sum(as.numeric(1:length(x))))#
	norm_x = normalize_level1(x)#
	res = data.frame(x = x, q = kvant_x, norm = norm_x)#
	res = res[!duplicated(x, fromLast = T), ]#
	return(res)#
}, .progress = "text")
qplot(round(norm), sum(x) * (1 - q), geom = "step", colour = sample, data = ll) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + theme_bw()
qplot(round(x), sum(x) * (1 - q), geom = "step", colour = sample, data = ll) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + theme_bw()
qplot(round(norm), sum(x) * (1 - q), geom = "step", colour = sample, data = ll) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + theme_bw() + opts(grid.major = theme_line(col = "grey60"))
qplot(round(norm), sum(x) * (1 - q), geom = "step", colour = sample, data = ll[1:100000, ]) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + theme_bw() + opts(panel.grid.major = theme_line(colour = "grey30"), panel.grid.minor = theme_line(colour = "grey30"))
expand.grid(c(-1,1), c(-1,1), c(-1,1), c(-1,1), c(-1,1))
hcv
hcl
?hcl
Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
pheatmap(test)#
pheatmap(test, scale = "row", clustering_distance = "correlation")#
pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))#
pheatmap(test, cellwidth = 15, cellheight = 12)#
pheatmap(test, cellwidth = 15, cellheight = 12, cluster_row = FALSE)#
pheatmap(test, cellwidth = 15, cellheight = 12, legend = FALSE)#
pheatmap(test, cellwidth = 15, cellheight = 12, fontsize = 8, filename = "~/Desktop/test.pdf")#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2")), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)#
pheatmap(test, annotation = annotation, annotation_legend = F)
#
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")
#
#
annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2")), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
 	width, height - manual options for determining the output file measurements in inches.#
#
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
#
#
#
#
#
#
#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 3, labels = c("Class1", "Class2", "Class3")), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
#
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
#
#
#
#
#
#
#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 3, labels = c("Class1", "Class2", "Class3")), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
#
#
#
#
#
#
#
#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 9), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
"Class3")), Var2 = 1:10)#
annotation = data.frame(Var1 = factor(1:10 %% 5), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
#
annotation = data.frame(Var1 = factor(1:10 %% 6), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
#
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
#
#
#
#
#
#
#
#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 6), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
#
annotation = data.frame(Var1 = factor(1:10 %% 8), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
is.null(coln)
is.null(NULL)
is.null(NULL[1])
pheatmap(test)
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
#
pheatmap(test)
library(colorspace)
 sequential_hcl()
 sequential_hcl(4)
 sequential_hcl(10)
?sequential_hcl(10)
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
#
pheatmap(test)
annotation = data.frame(Var1 = factor(1:10 %% 8), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)#
#
#
#
#
pheatmap(test, annotation = annotation, annotation_legend = F)
#
#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")
annotation = data.frame(Var1 = factor(1:10 %% 8), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
#
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
#
pheatmap(test)#
#
#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
#
#
#
#
#
#
#
#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 8), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
#
pheatmap(test)#
#
#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
#
#
#
#
#
#
#
#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 8), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)#
pheatmap(test, annotation = annotation, show_rownames = F)
pheatmap(test, annotation = annotation, show_colnames = F)
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")#
#
#
test = matrix(rnorm(200), 20, 10)#
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] #
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)]#
#
pheatmap(test)#
#
#
colnames(test) = paste("Test", 1:10, sep = "")#
rownames(test) = paste("Gene", 1:20, sep = "")#
   #
#
#
#
#
#
#
#
#
#
#
#
annotation = data.frame(Var1 = factor(1:10 %% 8), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)#
pheatmap(test, annotation = annotation, show_rownames = F)#
pheatmap(test, annotation = annotation, show_colnames = F)
annotation = data.frame(Var1 = factor(1:10 %% 3, labels = c("Class1", "Class2", "Class3")), Var2 = 1:10)#
rownames(annotation) = paste("Test", 1:10, sep = "")#
#
pheatmap(test, annotation = annotation)
#
Var1 = c("navy", "darkgreen")#
names(Var1) = c("Class1", "Class2")#
Var2 = c("lightgreen", "navy")#
#
ann_colors = list(Var1 = Var1, Var2 = Var2)
source("/Users/Kolde/Raivo/Projects/RHeatmap/pheatmap.r")
pheatmap(test, annotation = annotation, annotation_colors = ann_colors, cluster_rows = F)
#
Var1 = c("navy", "darkgreen", "darkred")#
names(Var1) = c("Class1", "Class2", "Class3")#
Var2 = c("lightgreen", "navy")#
#
ann_colors = list(Var1 = Var1, Var2 = Var2)#
#
pheatmap(test, annotation = annotation, annotation_colors = ann_colors)#
pheatmap(test, annotation = annotation, annotation_colors = ann_colors, cluster_rows = F)
#
Var1 = c("navy", "darkgreen", "darkred")#
names(Var1) = c("Class1", "Class2", "Class3")#
Var2 = c("lightgreen", "navy")#
#
ann_colors = list(Var1 = Var1, Var2 = Var2)#
#
pheatmap(test, annotation = annotation, annotation_colors = ann_colors)#
pheatmap(test, annotation = annotation, annotation_colors = ann_colors, cluster_cols = F)
#
Var1 = c("navy", "darkgreen", "darkred")#
names(Var1) = c("Class1", "Class2", "Class3")#
Var2 = c("lightgreen", "navy")#
#
ann_colors = list(Var1 = Var1, Var2 = Var2)#
#
pheatmap(test, annotation = annotation, annotation_colors = ann_colors)#
pheatmap(test, annotation = annotation, annotation_colors = ann_colors, show_colnames = F)
library(grid)#
library(colorspace)#
#
#
#
#
#
#
#
#
#
#
lo = function(rown, coln, cellheight = NA, cellwidth = NA, treeheight_col, treeheight_row, legend, annotation, annotation_colors, annotation_legend, ...){#
	#
	if(!is.null(coln[1])){#
		longest_coln = which.max(nchar(coln))#
		coln_height = unit(1.1, "grobheight", textGrob(coln[longest_coln], rot = 90, gp = gpar(...)))#
	}#
	else{#
		coln_height = unit(5, "bigpts")#
	}#
	#
	if(!is.null(rown[1])){#
		longest_rown = which.max(nchar(rown))#
		rown_width = unit(1.2, "grobwidth", textGrob(rown[longest_rown], gp = gpar(...)))#
	}#
	else{#
		rown_width = unit(5, "bigpts")#
	}#
	#
	#
	if(!is.na(legend[1])){#
		longest_break = which.max(nchar(as.character(legend)))#
		longest_break = unit(1.1, "grobwidth", textGrob(as.character(legend)[longest_break], gp = gpar(...)))#
		title_length = unit(1.1, "grobwidth", textGrob("Scale", gp = gpar(fontface = "bold", ...)))#
		legend_width = unit(12, "bigpts") + longest_break * 1.2#
		legend_width = max(title_length, legend_width)#
	}#
	else{#
		legend_width = unit(0, "bigpts")#
	}#
	#
	#
	if(!is.na(annotation[[1]][1])){#
		#
		annot_height = unit(ncol(annotation) * (8 + 2) + 2, "bigpts")#
		#
		longest_ann = which.max(nchar(as.matrix(annotation)))#
		annot_legend_width = unit(1.2, "grobwidth", textGrob(as.matrix(annotation)[longest_ann], gp = gpar(...))) + unit(12, "bigpts")#
		if(!annotation_legend){#
			annot_legend_width = unit(0, "npc")#
		}#
	}#
	else{#
		annot_height = unit(0, "bigpts")#
		annot_legend_width = unit(0, "bigpts")#
	}#
	#
	#
	treeheight_col = unit(treeheight_col, "bigpts") + unit(5, "bigpts")#
	treeheight_row = unit(treeheight_row, "bigpts") + unit(5, "bigpts") #
	#
	#
	if(is.na(cellwidth)){#
		matwidth = unit(1, "npc") - rown_width - legend_width - treeheight_row - annot_legend_width#
	}#
	else{#
		matwidth = unit(cellwidth * length(coln), "bigpts")#
	}#
	#
	if(is.na(cellheight)){#
		matheight = unit(1, "npc") - coln_height - treeheight_col - annot_height#
	}#
	else{#
		matheight = unit(cellheight * length(rown), "bigpts")#
	}	#
	#
	#
	pushViewport(viewport(layout = grid.layout(nrow = 4, ncol = 5, widths = unit.c(treeheight_row, matwidth, rown_width, legend_width, annot_legend_width), heights = unit.c(treeheight_col, annot_height, matheight, coln_height))))#
}#
#
draw_dendrogram = function(hc, horizontal = T){#
	h = hc$height / max(hc$height) / 1.05#
	m = hc$merge#
	o = hc$order#
	n = length(o)#
#
	m[m > 0] = n + m[m > 0] #
	m[m < 0] = abs(m[m < 0])#
#
	dist = matrix(0, nrow = 2 * n - 1, ncol = 2, dimnames = list(NULL, c("x", "y"))) #
	dist[1:n, 1] = 1 / n / 2 + (1 / n) * (match(1:n, o) - 1)#
#
	for(i in 1:nrow(m)){#
		dist[n + i, 1] = (dist[m[i, 1], 1] + dist[m[i, 2], 1]) / 2#
		dist[n + i, 2] = h[i]#
	}#
	#
	draw_connection = function(x1, x2, y1, y2, y){#
		grid.lines(x = c(x1, x1), y = c(y1, y))#
		grid.lines(x = c(x2, x2), y = c(y2, y))#
		grid.lines(x = c(x1, x2), y = c(y, y))#
	}#
	#
	if(horizontal){#
		for(i in 1:nrow(m)){#
			draw_connection(dist[m[i, 1], 1], dist[m[i, 2], 1], dist[m[i, 1], 2], dist[m[i, 2], 2], h[i])#
		}#
	}#
	#
	else{#
		gr = rectGrob()#
		pushViewport(viewport(height = unit(1, "grobwidth", gr), width = unit(1, "grobheight", gr), angle = 90))#
		for(i in 1:nrow(m)){#
			draw_connection(dist[m[i, 1], 1], dist[m[i, 2], 1], dist[m[i, 1], 2], dist[m[i, 2], 2], h[i])#
		}#
		upViewport()#
	}#
}#
#
draw_matrix = function(matrix, border_color){#
	n = nrow(matrix)#
	m = ncol(matrix)#
	x = (1:m)/m - 1/2/m#
	y = (1:n)/n - 1/2/n#
	for(i in 1:m){#
		grid.rect(x = x[i], y = y[1:n], width = 1/m, height = 1/n, gp = gpar(fill = matrix[,i], col = border_color))#
	}#
}#
#
draw_colnames = function(coln, ...){#
	m = length(coln)#
	x = (1:m)/m - 1/2/m#
	grid.text(coln, x = x, y = unit(0.96, "npc"), vjust = 0.5, hjust = 0, rot = 270, gp = gpar(...))#
}#
#
draw_rownames = function(rown, ...){#
	n = length(rown)#
	y = (1:n)/n - 1/2/n#
	grid.text(rown, x = unit(0.04, "npc"), y = y, vjust = 0.5, hjust = 0, gp = gpar(...))	#
}#
#
draw_legend = function(color, breaks, legend, ...){#
	height = min(unit(1, "npc"), unit(150, "bigpts"))#
	pushViewport(viewport(x = 0, y = unit(1, "npc"), just = c(0, 1), height = height))#
	legend_pos = (legend - min(breaks)) / (max(breaks) - min(breaks))#
	breaks = (breaks - min(breaks)) / (max(breaks) - min(breaks))#
	h = breaks[-1] - breaks[-length(breaks)]#
	grid.rect(x = 0, y = breaks[-length(breaks)], width = unit(10, "bigpts"), height = h, hjust = 0, vjust = 0, gp = gpar(fill = color, col = "#
	grid.text(legend, x = unit(12, "bigpts"), y = legend_pos, hjust = 0, gp = gpar(...))#
	upViewport()#
}#
#
convert_annotations = function(annotation, annotation_colors){#
	new = annotation#
	for(i in 1:ncol(annotation)){#
		a = annotation[, i]#
		b = annotation_colors[[colnames(annotation)[i]]]#
		#
		if(class(a) %in% c("character", "factor")){#
			a = as.character(a)#
			if(length(setdiff(names(b), a)) > 0){#
				stop(sprintf("Factor levels on variable %s do not match with annotation_colors", colnames(annotation)[i]))#
			}#
			new[, i] = b[a]#
		}#
		else{#
			a = cut(a, breaks = 100)#
			new[, i] = colorRampPalette(b)(100)[a]#
		}#
	}#
	return(as.matrix(new))#
}#
#
draw_annotations = function(converted_annotations, border_color){#
	n = ncol(converted_annotations)#
	m = nrow(converted_annotations)#
	x = (1:m)/m - 1/2/m#
	y = cumsum(rep(8, n)) - 4 + cumsum(rep(2, n))#
	for(i in 1:m){#
		grid.rect(x = x[i], unit(y[1:n], "bigpts"), width = 1/m, height = unit(8, "bigpts"), gp = gpar(fill = converted_annotations[i, ], col = border_color))#
	}#
}#
#
draw_annotation_legend = function(annotation, annotation_colors, border_color, ...){#
	y = unit(1, "npc")#
	text_height = unit(1, "grobheight", textGrob("FGH", gp = gpar(...)))#
	for(i in names(annotation_colors)){#
		grid.text(i, x = 0, y = y, vjust = 1, hjust = 0, gp = gpar(fontface = "bold", ...))#
		y = y - 1.5 * text_height#
		if(class(annotation[, i]) %in% c("character", "factor")){#
			for(j in 1:length(annotation_colors[[i]])){#
				grid.rect(x = unit(0, "npc"), y = y, hjust = 0, vjust = 1, height = text_height, width = text_height, gp = gpar(col = border_color, fill = annotation_colors[[i]][j]))#
				grid.text(names(annotation_colors[[i]])[j], x = text_height * 1.3, y = y, hjust = 0, vjust = 1, gp = gpar(...))#
				y = y - 1.5 * text_height#
			}#
		}#
		else{#
			yy = y - 4 * text_height + seq(0, 1, 0.02) * 4 * text_height#
			h = 4 * text_height * 0.02#
			grid.rect(x = unit(0, "npc"), y = yy, hjust = 0, vjust = 1, height = h, width = text_height, gp = gpar(col = "#
			txt = rev(range(grid.pretty(range(annotation[, i]))))#
			yy = y - c(0, 3) * text_height#
			grid.text(txt, x = text_height * 1.3, y = yy, hjust = 0, vjust = 1, gp = gpar(...))#
			y = y - 4.5 * text_height#
		}#
		y = y - 1.5 * text_height#
	}#
}#
#
#
vplayout = function(x, y){#
	return(viewport(layout.pos.row = x, layout.pos.col = y))#
}#
#
heatmap_motor = function(matrix, border_color, cellwidth, cellheight, tree_col, tree_row, treeheight_col, treeheight_row, filename, width, height, breaks, color, legend, annotation, annotation_colors, annotation_legend, ...){#
	grid.newpage()#
	#
	#
	lo(coln = colnames(matrix), rown = rownames(matrix), cellwidth = cellwidth, cellheight = cellheight, treeheight_col = treeheight_col, treeheight_row = treeheight_row, legend = legend, annotation = annotation, annotation_colors = annotation_colors, annotation_legend = annotation_legend, ...)#
	#
	#
	if(!is.na(tree_col[[1]][1])){#
		pushViewport(vplayout(1, 2))#
		draw_dendrogram(tree_col, horizontal = T)#
		upViewport()#
	}#
	#
	#
	if(!is.na(tree_row[[1]][1])){#
		pushViewport(vplayout(3, 1))#
		draw_dendrogram(tree_row, horizontal = F)#
		upViewport()#
	}#
	#
	#
	pushViewport(vplayout(3, 2))#
	draw_matrix(matrix, border_color)#
	upViewport()#
	#
	#
	if(length(colnames(matrix)) != 0){#
		pushViewport(vplayout(4, 2))#
		draw_colnames(colnames(matrix), ...)#
		upViewport()#
	}#
	#
	#
	if(length(rownames(matrix)) != 0){#
		pushViewport(vplayout(3, 3))#
		draw_rownames(rownames(matrix), ...)#
		upViewport()#
	}#
	#
	#
	if(!is.na(annotation[[1]][1])){#
		pushViewport(vplayout(2, 2))#
		converted_annotation = convert_annotations(annotation, annotation_colors)#
		draw_annotations(converted_annotation, border_color)#
		upViewport()#
	}#
	#
	#
	if(!is.na(annotation[[1]][1]) & annotation_legend){#
		pushViewport(vplayout(3, 5))#
		draw_annotation_legend(annotation, annotation_colors, border_color, ...)#
		upViewport()#
	}#
	#
	#
	if(!is.na(legend[1])){#
		pushViewport(vplayout(3, 4))#
		draw_legend(color, breaks, legend, ...)#
		upViewport()#
	}#
	#
	pushViewport(vplayout(1:4, 1:5))#
	#
	if(!is.na(filename)){#
		if(is.na(height)){#
			height = convertHeight(unit(0:1, "npc"), "inches", valueOnly = T)[2]#
		}#
		if(is.na(width)){#
			width = convertWidth(unit(0:1, "npc"), "inches", valueOnly = T)[2]#
		}#
		pdf(filename, height = height, width = width)#
		#
		heatmap_motor(matrix, cellwidth = cellwidth, cellheight = cellwidth, border_color = border_color, tree_col = tree_col, tree_row = tree_row, treeheight_col = treeheight_col, treeheight_row = treeheight_row, breaks = breaks, color = color, legend = legend, annotation = annotation, annotation_colors = annotation_colors, annotation_legend = annotation_legend, file = NA, ...)#
		dev.off()#
	}#
}#
#
generate_breaks = function(x, n){#
	seq(min(x, na.rm = T), max(x, na.rm = T), length.out = n + 1)#
}#
#
scale_vec_colours = function(x, col = rainbow(10), breaks = NA){#
	return(col[as.numeric(cut(x, breaks = breaks, include.lowest = T))])#
}#
#
scale_colours = function(mat, col = rainbow(10), breaks = NA){#
	mat = as.matrix(mat)#
	return(matrix(scale_vec_colours(as.vector(mat), col = col, breaks = breaks), nrow(mat), ncol(mat), dimnames = list(rownames(mat), colnames(mat))))#
}#
#
cluster_mat = function(mat, distance, method){#
	if(!(method %in% c("ward", "single", "complete", "average", "mcquitty", "median", "centroid"))){#
		stop("clustering method has to one form the list: 'ward', 'single', 'complete', 'average', 'mcquitty', 'median' or 'centroid'.")#
	}#
	if(!(distance %in% c("correlation", "euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"))){#
		stop("distance measure has to one form the list: 'correlation', 'euclidean', 'maximum', 'manhattan', 'canberra', 'binary', 'minkowski'")#
	}#
	if(distance == "correlation"){#
		d = dist(1 - cor(t(mat)))#
	}#
	else{#
		d = dist(mat, method = distance)#
	}#
	return(hclust(d, method = method))#
}#
#
scale_rows = function(x){#
	m = apply(x, 1, mean)#
	s = apply(x, 1, sd)#
	return((x - m) / s)#
}#
#
scale_mat = function(mat, scale){#
	if(!(scale %in% c("none", "row", "column"))){#
		stop("scale argument shoud take values: 'none', 'row' or 'column'")#
	}#
	mat = switch(scale, none = mat, row = scale_rows(mat), column = t(scale_rows(t(mat))))#
	return(mat)#
}#
#
generate_annotation_colours = function(annotation, annotation_colors){#
	if(is.na(annotation_colors)[[1]][1]){#
		annotation_colors = list()#
	}#
	count = 0#
	for(i in 1:ncol(annotation)){#
		if(class(annotation[, i]) %in% c("character", "factor")){#
			count = count + length(unique(annotation[, i]))#
		}#
	}#
	#
	factor_colors = hcl(h = seq(0, 360, length.out = count + 1)[-1], 75, 75)#
	#
	set.seed(5345)#
	#
	for(i in 1:ncol(annotation)){#
		if(!(colnames(annotation)[i] %in% names(annotation_colors))){#
			if(class(annotation[, i]) %in% c("character", "factor")){#
				ind = sample(1:length(factor_colors), length(unique(annotation[, i])))#
				annotation_colors[[colnames(annotation)[i]]] = factor_colors[ind]#
				names(annotation_colors[[colnames(annotation)[i]]]) = levels(as.factor(annotation[, i]))#
				factor_colors = factor_colors[-ind]#
			}#
			else{#
				h = round(runif(1) * 360)#
				annotation_colors[[colnames(annotation)[i]]] = rev(sequential_hcl(2, h, l = c(50, 95)))#
			}#
		}#
	}#
	return(annotation_colors)#
}#
#
#
pheatmap = function(mat, color = colorRampPalette(rev(c("#
	#
	#
	mat = as.matrix(mat)#
	mat = scale_mat(mat, scale)#
	#
	#
	if(cluster_rows){#
		tree_row = cluster_mat(mat, distance = clustering_distance, method = clustering_method)#
		mat = mat[tree_row$order, ]#
	}#
	else{#
		tree_row = NA#
		treeheight_row = 0#
	}#
	#
	if(cluster_cols){#
		tree_col = cluster_mat(t(mat), distance = clustering_distance, method = clustering_method)#
		mat = mat[, tree_col$order]#
	}#
	else{#
		tree_col = NA#
		treeheight_col = 0#
	}#
	#
	#
	if(is.na(breaks[1])){#
      breaks = generate_breaks(as.vector(mat), length(color))#
  }#
  if (legend) {#
      legend = grid.pretty(range(as.vector(breaks)))#
  }#
  else {#
      legend = NA#
  }#
	mat = scale_colours(mat, col = color, breaks = breaks)#
	#
	#
	if(!is.na(annotation[[1]][1])){#
		annotation = annotation[colnames(mat), , drop = F]#
		annotation_colors = generate_annotation_colours(annotation, annotation_colors)#
	}#
	#
	if(!show_rownames){#
		rownames(mat) = NULL#
	}#
	#
	if(!show_colnames){#
		colnames(mat) = NULL#
	}#
	#
	#
	heatmap_motor(mat, border_color = border_color, cellwidth = cellwidth, cellheight = cellheight, treeheight_col = treeheight_col, treeheight_row = treeheight_row, tree_col = tree_col, tree_row = tree_row, filename = filename, width = width, height = height, breaks = breaks, color = color, legend = legend, annotation = annotation, annotation_colors = annotation_colors, annotation_legend = annotation_legend, ...)#
}
?INSTALL
C_LIB = "~/Raivo/Projects/RRA/R/C" #
#
#
invert_vec_ranks = function(vec){#
	return(match(1:length(vec), vec))#
}#
invert_ranks = function(rmat){#
	return(apply(rmat, 2, invert_vec_ranks))#
}#
#
#
aggregateMC = function(R, method = "MC4"){#
	eps = 0.15#
	n = nrow(R)#
	m = ncol(R)#
	R[is.na(R)] = 0#
	P = matrix(0, n, n)#
	#
	#
	#
		#
		for(c in 1:m){#
			for(i in 1:(n-1)){#
				for(j in (i+1):n){#
					ti = R[i, c]#
					tj = R[j, c]#
					if(ti == 0 | tj == 0){#
						next#
					}#
					else if(ti > tj){#
						P[i, j] = P[i, j] + 1#
					}#
					else{#
						P[j, i] = P[j, i] + 1#
					}#
				}#
			}#
		}#
		#
		#
				#
				#
				#
				#
				#
				#
				#
				#
				#
				#
				#
				#
				#
				#
				#
				#
	#
	P1 = P#
	P = matrix(0, n, n)#
	storage.mode(R) = "integer"#
	#
	dyn.load(sprintf("%s/mc4.so", C_LIB))#
	P2 = .C("mc4", R = R, n = as.integer(n), m = as.integer(m), P = P)$P#
	#
	return(list(P = P1, P2 = P2))#
	#
	P = P / n#
	diag(P) = 1 - apply(P, 1, sum)#
	#
	#
	P = (1 - eps) * P + eps / n#
	#
	#
	ones = rep(1, n)#
	Pi = drop(t(ones) %*% qr.solve(diag(1, n) - P + 1))#
	ranking = rank(-Pi, ties.method = "first")#
	#
	return(rownames(R)[ranking])#
}#
#
m2 = aggregateMC(test, method = "MC4")#
sum(abs(m2$P - m2$P2))#
head(m2$P2)#
head(m2$P)#
#
seed = rnorm(100)#
permute = function(x) order(x + rnorm(length(x), sd = 0.1))#
t = cbind(replicate(10, permute(seed)), sample(1:100))#
test = invert_ranks(t)#
rownames(test) = 1:nrow(test)#
test[sample(1:length(test), 750)] = NA#
ot = order(seed)#
#
par(mfrow = c(1, 2))#
plot(aggregateMC(test, method = "MC4"), invert_vec_ranks(ot))#
plot(invert_vec_ranks(aggregateMC(test, method = "MC4")), ot)
?do.call()
mat = matrix(rnorm(1000000), ncol = 10)
install.packages("RODBC")
library("RODBC")
.quit;
warnings()
?odbcConnect("mysql", uid = "albin", pwd = "albin")
ch <- odbcConnect("mysql", uid = "albin", pwd = "albin")
install.packages("RMySQL")
library("RMySQL")
 install.packages('RMySQL',type='source')
 install.packages('RODBC',type='source')
setClass("rra.slist",#
	representation(description = "character", order = "numeric"),#
	prototype(description = "", order = 0), #
	contains = "data.frame",#
	validity =  function(object)#
	{#
		if(length(object@order) !=1 || is.nan(object@order)) return("Slot order must be in the range {-1,0,1}")#
		if(dim(object)[2] <=1 ) return("There must be at least two columns in the data frame")#
		if(object@order > 0 && is.unsorted(object[,2])) return("The second column in the data frame is not ordered acendingly")#
		if(object@order < 0 && is.unsorted(-object[,2])) return("The second column in the date frame is not ordered descendingly")#
		return(TRUE)  #
	}, #
	sealed = FALSE)#
#
#
setMethod("show", signature(object = "rra.slist"), #
	definition = function(object)#
	{#
		if(length(object@description) > 0) cat(sprintf("%s#
", object@description))#
		cat(sprintf("Size: %d x %d#
", dim(object)[1], dim(object)[2]))#
		if(!is.na(object@order) && object@order <  0) cat("Order: descending#
#
")#
		if(!is.na(object@order) && object@order >  0) cat("Order: ascending#
#
")#
		if(!is.na(object@order) && object@order == 0) cat("Order: unordered#
#
")#
		#
		if(dim(object)[1]<=20) print(as(object,"data.frame"))#
		else#
		{#
			print(as(object[1:20, ],"data.frame"))#
			cat("...#
#
Use head(...) or tail(...) to print out more elements od the list")#
		} #
	}, #
	sealed = FALSE)#
#
#
setMethod("head", "rra.slist",#
	definition = function(x, n = NULL, threshold, ...)#
	{#
		if(dim(x)[2] <=1 || x@order == 0 || missing(threshold))#
		{#
			if(is.null(n)) return(new("rra.slist", head(as(x, "data.frame"), ...), description = x@description, order = x@order))#
			else return(new("rra.slist", head(as(x, "data.frame"), n, ...), description = x@description, order = x@order))#
		}#
		if(x@order < 0) #
		{#
			if(is.null(n)) return(new("rra.slist", head(as(x[x[, 2] >= threshold, ], "data.frame"), ...), description = x@description, order = x@order))#
			else return(new("rra.slist", head(as(x[x[, 2] >= threshold, ], "data.frame"), n, ...), description = x@description, order = x@order))#
		}#
		else#
		{#
			if(is.null(n)) return(new("rra.slist", head(as(x[x[, 2] <= threshold, ], "data.frame"), ...), description = x@description, order = x@order)) #
			else return(new("rra.slist", head(as(x[x[, 2] <= threshold, ], "data.frame"), n, ...), description = x@description, order = x@order)) #
		} #
	},#
	sealed = FALSE)#
#
#
setMethod("tail", "rra.slist",#
	definition = function(x, n = NULL, threshold, ...)#
	{#
		if(dim(x)[2] <=1 || x@order == 0 || missing(threshold))#
		{#
			if(is.null(n)) return(new("rra.slist", tail(as(x, "data.frame"), ...), description = x@description, order = x@order))#
			else return(new("rra.slist", tail(as(x, "data.frame"), n, ...), description = x@description, order = x@order))#
		}#
		if(x@order < 0) #
		{#
			if(is.null(n)) return(new("rra.slist", tail(as(x[x[, 2] <= threshold, ],"data.frame"), ...), description = x@description, order = x@order))#
			else return(new("rra.slist", tail(as(x[x[, 2] <= threshold, ], "data.frame"), n, ...), description = x@description, order = x@order))#
		}#
		else#
		{#
			if(is.null(n)) return(new("rra.slist", tail(as(x[x[, 2] >= threshold, ], "data.frame"), ...), description = x@description, order = x@order)) #
			else return(new("rra.slist", tail(as(x[x[, 2] >= threshold, ], "data.frame"), n, ...), description = x@description, order = x@order)) #
		} #
	},#
	sealed = FALSE)#
#
#
setMethod("plot", signature(x="rra.slist", y="missing"),	definition = function(x, threshold = NULL, breaks = "Sturges", col = "green", xlab = NULL, main = NULL, ...)#
	{#
		if(dim(x)[2]<=1) stop("there must be at least 2 columns in the data frame")#
#
		if(is.null(xlab)) xlab <- names(x)[2]  #
		if(is.null(main)) main <- sprintf("Histogram of scores (count = %d)",dim(x)[1])#
		#
		hist(x[, 2], breaks = breaks, col = col, xlab = xlab, main = main,...)#
#
		if(!is.null(threshold)) points(threshold, -rep(par("cin")[2],length(threshold)), pch=24, col="red", bg="red")		#
 	},#
 	sealed = FALSE)#
#
 	#
setMethod("plot", signature(x="rra.slist", y="numeric"),#
	definition = function(x, y, breaks = "Sturges", col = "green", xlab = NULL, main = NULL, ...)#
	{#
		plot(x, threshold=y, breaks = breaks, col = col, xlab = xlab, main = main, ...)#
	},#
	sealed = FALSE)#
#
#
NewScoreList <- function(scores, score.names, ordering = "descending", description="List of Scores")#
{#
	if(!missing(score.names))#
	{#
		if(length(scores) != length(score.names)) stop("the lengths of score and score.names must be equal")#
		names(scores) <- score.names#
	} #
	#
	if(is.null(names(scores))) names(scores) <- rep(NA,length(scores))#
	#
	#
	if(ordering == "ascending")#
	{#
			scores <- sort(scores)#
			return(new("rra.slist", data.frame(Name = names(scores), Score = scores, row.names = NULL), description = description, order = 1))#
	}#
	else if(ordering == "descending")#
	{#
			scores <- sort(scores, decreasing = TRUE)#
			return(new("rra.slist", data.frame(Name = names(scores), Score = scores, row.names = NULL), description = description, order = -1))#
	}#
	else if(ordering == "none")#
	{ #
			return(new("rra.slist", data.frame(Name = names(scores), Score = scores, row.names = NULL), description = description, order = 0))#
	}#
	else#
	{#
		stop("unknown ordering method")#
	}#
} #
#
#
#
#
setClass("rra.plist",#
	representation(hyp.count = "numeric"),#
	prototype(hyp.count = 1),#
	contains = "rra.slist",#
	validity = function(object)#
	{#
		if(length(object@hyp.count)!=1 || is.nan(object@hyp.count) || object@hyp.count < 1) #
		{#
			return("Number of multiple hypotheses to be tested against must be in the range [1,Inf]")#
		} #
		return(TRUE)#
	},#
	sealed = FALSE)#
#
#
setMethod("show", signature(object = "rra.plist"), #
	definition = function(object)#
	{#
		if(length(object@description) > 0) cat(sprintf("%s#
", object@description))#
		cat(sprintf("Size: %d x %d#
", dim(object)[1], dim(object)[2]))#
		if(!is.na(object@order) && object@order <  0) cat("Order: descending#
")#
		if(!is.na(object@order) && object@order >  0) cat("Order: ascending#
")#
		if(!is.na(object@order) && object@order == 0) cat("Order: unordered#
")#
		cat(sprintf("Default sign. threshold: %.2g#
", 0.05/object@hyp.count)) #
		cat(sprintf("Number of significant scores: %d#
#
", sum(object[,2]<=0.05/object@hyp.count))) #
		#
		if(dim(object)[1]<=20) print(as(object,"data.frame"))#
		else#
		{#
			print(as(object[1:20, ],"data.frame"))#
			cat("...#
#
Use head(...) or tail(...) to print out more elements od the list")#
		} #
		#
	},#
	sealed = FALSE)#
	#
#
setMethod("head", "rra.plist",#
	definition = function(x, n = NULL, threshold, correct.threshold = TRUE, ...)#
	{#
		if(is.null(n) && missing(threshold))#
		{#
			threshold <- 0.05#
			n <- Inf#
		}#
		#
		if(!missing(threshold) && correct.threshold) threshold <- threshold/x@hyp.count#
#
		if(missing(threshold)) 	return(new("rra.plist", head(as(x, "rra.slist"), n = n, ...), hyp.count = x@hyp.count))#
		else return(new("rra.plist", head(as(x, "rra.slist"), n = n, threshold = threshold, ...), hyp.count = x@hyp.count))#
	},#
	sealed = FALSE)#
#
#
setMethod("tail", "rra.plist",#
	definition = function(x, n = NULL, threshold, correct.threshold = TRUE, ...)#
	{#
		if(is.null(n) && missing(threshold))#
		{#
			threshold <- 0.05#
			n <- Inf#
		}#
		#
		if(!missing(threshold) && correct.threshold) threshold <- threshold/x@hyp.count#
#
		if(missing(threshold)) 	return(new("rra.plist", tail(as(x, "rra.slist"), n = n, ...), hyp.count = x@hyp.count))#
		else return(new("rra.plist", tail(as(x, "rra.slist"), n = n, threshold = threshold, ...), hyp.count = x@hyp.count))#
		#
	},#
	sealed = FALSE)#
#
#
setMethod("plot", signature(x="rra.plist", y="missing"),	definition = function(x, threshold = 0.05, breaks = "Sturges", col = "green", xlab = NULL, main = NULL, correct.threshold = TRUE, ...)#
	{#
		if(correct.threshold && !is.null(threshold)) threshold <- threshold/x@hyp.count#
		plot(as(x, "rra.slist"), threshold=threshold, breaks = breaks, col = col, xlab = xlab, main = main, ...)#
	},#
	sealed = FALSE)#
#
#
setMethod("plot", signature(x="rra.plist", y="numeric"),#
	definition = function(x, y, breaks = "Sturges", col = "green", xlab = NULL, main = NULL, correct.threshold = TRUE, ...)#
	{#
		plot(x, threshold=y, breaks = breaks, col = col, xlab = xlab, main = main, correct.threshold = correct.threshold, ...)#
	},#
	sealed = FALSE)#
#
#
NewPValueList <- function(pvalues, pvalue.names, hyp.count = 1, ordering = "ascending", description="List of P-values")#
{#
	return(new("rra.plist", NewScoreList(pvalues, pvalue.names, ordering = ordering, description = description), hyp.count = hyp.count))#
} #
#
makeRankMatrix <-  function(glist, N = NA, full = F){#
	u <- unique(c(glist, recursive = T))#
	#
	if(is.na(N)){#
		N = length(u)#
	}#
	if(!full){#
		rmat <- matrix(1, nrow = length(u), ncol = length(glist), dimnames = list(u, names(glist)))#
	}#
	else{#
		rmat <- matrix(NA, nrow = length(u), ncol = length(glist), dimnames = list(u, names(glist)))#
	}#
	for(i in 1:length(glist)){#
		rmat[glist[[i]], i] <- (1:length(glist[[i]])) / length(glist[[i]])#
	}#
	return(rmat)#
}#
#
#
calculateBetaPvalues <- function(r){#
	n <- sum(!is.na(r))#
	p <- rep(1, n)#
	r <- sort(r, na.last = T)#
	p <- pbeta(r, 1:n, n - 1:n + 1)#
	return(p)#
} #
#
correctBetaPvalues <- function(p, k, cons = T){#
	p = pbeta(p, 1, k)#
	return(p)#
}#
#
#
sumStuart <- function(v, r){#
	k = length(v)#
	l_k = 1:k#
	ones = (-1)**(l_k + 1)#
	f = factorial(l_k)#
	p = r ** l_k#
	return(ones %*% (rev(v) * p / f))#
}#
#
qStuart <- function(r){#
	N = sum(!is.na(r))#
	v = rep(1, N + 1)#
	for(k in 1:N){#
		v[k + 1] = sumStuart(v[1:k], r[N - k + 1])#
	}#
	return(factorial(N) * v[N + 1])#
}#
#
stuart <- function(rmat){#
	rmat <- t(apply(rmat, 1, sort, na.last = T))#
	return(apply(rmat, 1, qStuart))#
}#
#
invertVecRanks <- function(vec){#
	return(match(1:length(vec), vec))#
}#
#
invertRanks <- function(rmat){#
	return(apply(rmat, 2, invertVecRanks))#
}#
#
#
#
aggregateRanks <-  function(glist, rmat = makeRankMatrix(glist, N, full = full), N = NA, method = "RRA", full = F){#
	if(!(method %in% c("mean", "min", "median", "geom.mean", "RRA", "stuart"))){#
		stop("method should be one of:  'min', 'geom.mean', 'mean', 'median', 'stuart' or 'RRA' ")#
	}#
	#
	if(is.na(N)){#
		N <- nrow(rmat)#
	}#
	#
	if(is.null(rownames(rmat))){#
		rownames(rmat) <- 1:nrow(rmat)#
	}#
	#
	if(method == "min"){#
		a <-  apply(rmat, 1, min, na.rm = T)#
		return(NewScoreList(scores = a, score.names = names(a), description = "Rank aggregation results with method: min", ordering = "ascending"))#
	}#
	if(method == "median"){#
		a <- apply(rmat, 1, median, na.rm = T)#
		return(NewScoreList(scores = a, score.names = names(a), description = "Rank aggregation results with method: median", ordering = "ascending"))#
	}#
	if(method == "geom.mean"){#
		a <-  apply(rmat, 1, function(x) mean(log(x), na.rm = T))#
		return(NewScoreList(scores = a, score.names = names(a), description = "Rank aggregation results with method: geom.mean", ordering = "ascending"))#
	}#
	if(method == "RRA"){#
		rmat <- t(apply(rmat, 1, sort, na.last = T))#
		pmat <- t(apply(rmat, 1, calculateBetaPvalues))#
		a <- apply(pmat, 1, min, na.rm = T)#
		n <- apply(rmat, 1, function(x) sum(!is.na(x)))#
		a <- mapply(correctBetaPvalues, a, k = n)#
		names(a) <- rownames(rmat)#
		return(NewPValueList(pvalues = a, pvalue.names = names(a), description = "Rank aggregation results with method: RRA", ordering = "ascending"))#
	}#
	if(method == "mean"){#
		a <- apply(rmat, 1, mean, na.rm = T)#
		n <- apply(rmat, 1, function(x) sum(!is.na(x)))#
		b <- pnorm(a, 0.5, sqrt(1/12/n))#
		return(NewPValueList(pvalues = b, pvalue.names = names(a), description = "Rank aggregation results with method: mean", ordering = "ascending"))#
	}#
	if(method == "stuart"){#
		a <- stuart(rmat)#
		return(NewScoreList(scores = a, score.names = names(a), description = "Rank aggregation results with method: stuart", ordering = "ascending"))#
	}#
}
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
makeRankMatrix <-  function(glist, N = NA, full = F){#
	u <-  unique(c(glist, recursive = T))#
	#
	if(is.na(N)){#
		N = length(u)#
	}#
	if(!full){#
		rmat <- matrix(1, nrow = length(u), ncol = length(glist), dimnames = list(u, names(glist)))#
	}#
	else{#
		rmat <- matrix(NA, nrow = length(u), ncol = length(glist), dimnames = list(u, names(glist)))#
	}#
	for(i in 1:length(glist)){#
		rmat[glist[[i]], i] <- (1:length(glist[[i]])) / length(glist[[i]])#
	}#
	return(rmat)#
}#
#
#
formatOutput <- function(scores, score.names, ordering = "ascending"){#
	res = data.frame(Name = score.names, Score = scores)#
	if("ascending"){#
		res = res[order(res$Score), ]#
	}#
	else{#
		res = res[order(res$Score, decreasing = T), ]#
	}#
	return(res)#
} #
#
#
calculateBetaPvalues <- function(r){#
	n <- sum(!is.na(r))#
	p <- rep(1, n)#
	r <- sort(r, na.last = T)#
	p <- pbeta(r, 1:n, n - 1:n + 1)#
	return(p)#
} #
#
correctBetaPvalues <- function(p, k, cons = T){#
	p = pbeta(p, 1, k)#
	return(p)#
}#
#
#
sumStuart <- function(v, r){#
	k = length(v)#
	l_k = 1:k#
	ones = (-1)**(l_k + 1)#
	f = factorial(l_k)#
	p = r ** l_k#
	return(ones %*% (rev(v) * p / f))#
}#
#
qStuart <- function(r){#
	N = sum(!is.na(r))#
	v = rep(1, N + 1)#
	for(k in 1:N){#
		v[k + 1] = sumStuart(v[1:k], r[N - k + 1])#
	}#
	return(factorial(N) * v[N + 1])#
}#
#
stuart <- function(rmat){#
	rmat <- t(apply(rmat, 1, sort, na.last = T))#
	return(apply(rmat, 1, qStuart))#
}#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
aggregateRanks <-  function(glist, rmat = makeRankMatrix(glist, N, full = full), N = NA, method = "RRA", full = F){#
#
	if(!(method %in% c("mean", "min", "median", "geom.mean", "RRA", "stuart"))){#
		stop("method should be one of:  'min', 'geom.mean', 'mean', 'median', 'stuart' or 'RRA' ")#
	}#
	#
	if(is.na(N)){#
		N <- nrow(rmat)#
	}#
	#
	if(is.null(rownames(rmat))){#
		rownames(rmat) <- 1:nrow(rmat)#
	}#
	#
	if(method == "min"){#
		a <-  apply(rmat, 1, min, na.rm = T)#
		return(formatOutput(scores = a, score.names = names(a), ordering = "ascending"))#
	}#
	if(method == "median"){#
		a <- apply(rmat, 1, median, na.rm = T)#
		return(formatOutput(scores = a, score.names = names(a), ordering = "ascending"))#
	}#
	if(method == "geom.mean"){#
		a <-  apply(rmat, 1, function(x) mean(log(x), na.rm = T))#
		return(formatOutput(scores = a, score.names = names(a), ordering = "ascending"))#
	}#
	if(method == "RRA"){#
		rmat <- t(apply(rmat, 1, sort, na.last = T))#
		pmat <- t(apply(rmat, 1, calculateBetaPvalues))#
		a <- apply(pmat, 1, min, na.rm = T)#
		n <- apply(rmat, 1, function(x) sum(!is.na(x)))#
		a <- mapply(correctBetaPvalues, a, k = n)#
		names(a) <- rownames(rmat)#
		return(formatOutput(pvalues = a, pvalue.names = names(a), ordering = "ascending"))#
	}#
	if(method == "mean"){#
		a <- apply(rmat, 1, mean, na.rm = T)#
		n <- apply(rmat, 1, function(x) sum(!is.na(x)))#
		b <- pnorm(a, 0.5, sqrt(1/12/n))#
		return(formatOutput(pvalues = b, pvalue.names = names(a), ordering = "ascending"))#
	}#
	if(method == "stuart"){#
		a <- stuart(rmat)#
		return(formatOutput(scores = a, score.names = names(a), ordering = "ascending"))#
	}#
}
formatOutput <- function(scores, score.names, ordering = "ascending"){#
	res = data.frame(Name = score.names, Score = scores)#
	if(ordering == "ascending"){#
		res = res[order(res$Score), ]#
	}#
	else{#
		res = res[order(res$Score, decreasing = T), ]#
	}#
	return(res)#
}
#
#
glist <- list(sample(letters, 4), sample(letters, 10), sample(letters, 12))#
#
#
ar = aggregateRanks(glist = glist, method = "RRA");ar#
ar = aggregateRanks(glist = glist, method = "min");ar#
ar = aggregateRanks(glist = glist, method = "median");ar#
ar = aggregateRanks(glist = glist, method = "geom.mean");ar#
ar = aggregateRanks(glist = glist, method = "stuart");ar#
ar = aggregateRanks(glist = glist, method = "mean");ar
library(GenomicFeatures)#
library(rtracklayer)#
library(GenomicRanges)#
library(stringr)#
library(plyr)#
#
#
session = browserSession()
genome(session) = "hg18"
#
query = ucscTableQuery(session, "rmsk")#
rmsk_table = getTable(query)#
#
u = unique(rmsk_table$repClass)#
#
repeats = mlply(data.frame(u), function(u){#
	tab = subset(rmsk_table, repClass == u)#
	GRanges(#
		seqnames = Rle(tab$genoName),#
		ranges = IRanges(start = tab$genoStart, end = tab$genoEnd),#
		strand = Rle(tab$strand)#
	)#
})#
#
names(repeats) = u
source("http://bioconductor.org/biocLite.R")#
    biocLite("rtracklayer")
update.packages()
tmp <- installed.packages()#
installedpkgs <- as.vector(tmp[is.na(tmp[,"Priority"]), 1])#
save(installedpkgs, file="installed_old.rda")
temp = c(-6.2, -12.9, -13.0, -15.4, -16.1, -16.9, -17.0, -19.6, -19.9) jaam = c("Ruhnu", "Kihnu", "Pakri", "Tallinn", "Pärnu", "Kunda", "Kuusiku", "Võru", "Jõgeva")
jaam = c("Ruhnu", "Kihnu", "Pakri", "Tallinn", "Pärnu", "Kunda", "Kuusiku", "Voru", "Jogeva")
(36896 + log(36896)) / sin(36896) + log(36896) + 36896
piirkond = rep(c("saar", "rannik", "sise"), each = 3); piirkond
temp = c(-6.2, -12.9, -13.0, -15.4, -16.1, -16.9, -17.0, -19.6, -19.9) #
jaam = c("Ruhnu", "Kihnu", "Pakri", "Tallinn", "Pärnu", "Kunda", "Kuusiku", "Voru", "Jogeva")
andmed = data.frame(jrk = 1:9, piirkond, jaam, temp)
andmed
ED
read.table("~/Desktop/julia.txt")
read.table("~/Desktop/julia.txt", head= T)
d = read.table("~/Desktop/julia.txt", head= T)a
d = read.table("~/Desktop/julia.txt", head= T)
head(d)
melt(d)
write.table(melt(d))
write.table(melt(d), quote = F, row.names= F, col.names = F)
write.table(melt(d), file = "~/Desktop/juliamelt.txt",  quote = F, row.names= F, col.names = F)
write.table(melt(d), file = "~/Desktop/juliamelt.txt",  quote = F, row.names= F, col.names = F, sep = "\t")
d
melt(d, id.vars = V1)
melt(d, id.vars = "V1")
d = read.table("~/Desktop/bastian1.txt", head= F, sep = "\t")
d2 = melt(d, id.vars = "V1")
write.table(d2[,c(1, 3)], file = "~/Desktop/bastian1melt.txt",  quote = F, row.names= F, col.names = F, sep = "\t")
d2
library(RobustRankAggreg)
?aggregateRanks
#
	test = matrix(rnorm(200), 20, 10)#
	test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3#
	test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2#
	colnames(test) = paste("Test", 1:10, sep = "")#
	rownames(test) = paste("Gene", 1:20, sep = "")#
#
	#
	pheatmap(test)
#
	annotation = data.frame(Var1 = factor(1:10 %% 2 == 0, labels = c("Class1", "Class2"))#
	, Var2 = 1:10)#
	rownames(annotation) = paste("Test", 1:10, sep = "")#
#
	pheatmap(test, annotation = annotation)
Var1 = c("navy", "darkgreen")#
	names(Var1) = c("Class1", "Class2")#
	Var2 = c("lightgreen", "navy")#
#
	ann_colors = list(Var1 = Var1, Var2 = Var2)
#
#
"""#
melt.py#
#
Created by Raivo Kolde on 2011-03-03.#
Copyright (c) 2011 University of Tartu. All rights reserved.#
"""#
#
import sys#
import getopt#
import re#
#
#
def main(anrgv = None):#
	files = sys.argv[1:].strip().split(" ")#
	print files#
	#
#
#
if __name__ == "__main__":#
	sys.exit(main())
R
library(gProfileR)
gp<-gprofiler(organism="hsapiens", upNames, ordered_query=0, significant=1)
a = c("ENSG00000136826", "ENSG00000111704",  "ENSG00000181449")
gprofiler <- function(organism='hsapiens', query, ordered_query=0, significant=1) {#
	#
	query_url = ""#
#
	if (is.list(query)) {#
		for (i in 1:length(query)) {#
			query_url <- paste(sep="#
", query_url, paste("> query", i), paste(query[[i]], collapse=" "))#
		}#
	} else if (is.vector(query)) {#
		query_url <- paste(query, collapse=" ")#
	} else {#
		print("ERROR missing query")#
		return()#
	}#
	#
	my_url <- "http://biit.cs.ut.ee/gprofiler/gcocoa.cgi"#
	#
	raw_query <- RCurl::postForm(my_url, #
		organism=organism, #
		output='mini', #
		query=query_url, #
		analytical="1", #
		sort_by_structure="1", #
		significant=as.character(significant), #
		ordered_query=as.character(ordered_query)#
	)#
#
	split_query <- unlist(strsplit(raw_query, split="#
"))#
	#
	commented_lines <- grep("^#
	if (length(commented_lines)>0) {#
		split_query <- split_query[-commented_lines]#
	}#
	empty_lines <- which(split_query == "")#
	if (length(empty_lines)>0) {#
		split_query <- split_query[-empty_lines]#
	}#
	html <- grep("^<", split_query)#
	if (length(html)>0) {#
		split_query <- split_query[-html]#
	}#
#
	split_query <- t(as.data.frame(strsplit(split="	", split_query)))#
#
	if (dim(split_query)[1] == 0) {#
			split_query <- matrix(NA, 0, 13)#
	}#
	split_query[,12] <- gsub("^\s+", "", split_query[,12])#
	#
	split_query[,2][which(split_query[,2] == "")] <- 0#
	split_query[,2][which(split_query[,2] == "!")] <- 1#
	#
	rownames(split_query) <- NULL#
	colnames(split_query) <- c(#
		"query.number", "significant", "p.value", #
		"term.size", "query.size", "overlap.size", #
		"precision", "recall", "term.id", #
		"domain", "subgraph.number", "term.name", "relative.depth")#
	#
	split_query <- as.data.frame(split_query, colClasses=c("numeric"))#
	split_query[,3] <- as.numeric(gsub("e","E",split_query[,3]))#
	#
	return(split_query)#
}
gprofiler <- function(organism='hsapiens', query, ordered_query=0, significant=1) {#
	#
	query_url = ""#
#
	if (is.list(query)) {#
		for (i in 1:length(query)) {#
			query_url <- paste(sep="\n", query_url, paste("> query", i), paste(query[[i]], collapse=" "))#
		}#
	} else if (is.vector(query)) {#
		query_url <- paste(query, collapse=" ")#
	} else {#
		print("ERROR missing query")#
		return()#
	}#
	#
	my_url <- "http://biit.cs.ut.ee/gprofiler/gcocoa.cgi"#
	#
	raw_query <- RCurl::postForm(my_url, #
		organism=organism, #
		output='mini', #
		query=query_url, #
		analytical="1", #
		sort_by_structure="1", #
		significant=as.character(significant), #
		ordered_query=as.character(ordered_query)#
	)#
#
	split_query <- unlist(strsplit(raw_query, split="\n"))#
	#
	commented_lines <- grep("^#
	if (length(commented_lines)>0) {#
		split_query <- split_query[-commented_lines]#
	}#
	empty_lines <- which(split_query == "")#
	if (length(empty_lines)>0) {#
		split_query <- split_query[-empty_lines]#
	}#
	html <- grep("^<", split_query)#
	if (length(html)>0) {#
		split_query <- split_query[-html]#
	}#
#
	split_query <- t(as.data.frame(strsplit(split="\t", split_query)))#
#
	if (dim(split_query)[1] == 0) {#
			split_query <- matrix(NA, 0, 13)#
	}#
	split_query[,12] <- gsub("^\\s+", "", split_query[,12])#
	#
	split_query[,2][which(split_query[,2] == "")] <- 0#
	split_query[,2][which(split_query[,2] == "!")] <- 1#
	#
	rownames(split_query) <- NULL#
	colnames(split_query) <- c(#
		"query.number", "significant", "p.value", #
		"term.size", "query.size", "overlap.size", #
		"precision", "recall", "term.id", #
		"domain", "subgraph.number", "term.name", "relative.depth")#
	#
	split_query <- as.data.frame(split_query, colClasses=c("numeric"))#
	split_query[,3] <- as.numeric(gsub("e","E",split_query[,3]))#
	#
	return(split_query)#
}
gprofiler(organism="hsapiens", a, ordered_query=0, significant=1)
gprofiler(organism="hsapiens", c("a", "b", "c"), ordered_query=0, significant=1)
plot(rexp(100), rexp(100))
plot(rexp(1000), rexp(1000))
rnorm(mean = rep(0.1, 0.12, 0.3, 0.6, 0.9))
rnorm(15, mean = rep(c(0.1, 0.12, 0.3, 0.6, 0.9), by = 3))
rnorm(15, mean = rep(c(0.1, 0.12, 0.3, 0.6, 0.9), by = 3), sd = 0.05)
rnorm(15, mean = rep(c(0.1, 0.12, 0.3, 0.6, 0.9), times = 3), sd = 0.05)
?rep
rnorm(15, mean = rep(c(0.1, 0.12, 0.3, 0.6, 0.9), each = 3), sd = 0.05)
resp = rnorm(15, mean = rep(c(0.1, 0.12, 0.3, 0.6, 0.9), each = 3), sd = 0.05)
dose = rep(c(1:5)
dose = rep(c(1:5), each = 3)
resp = rnorm(15, mean = rep(c(0.1, 0.12, 0.3, 0.6, 0.9, 0.1, 0.1, 0.2, 0.5, 0.9), each = 3), sd = 0.05)
resp
resp = rnorm(30, mean = rep(c(0.1, 0.12, 0.3, 0.6, 0.9, 0.1, 0.1, 0.2, 0.5, 0.9), each = 3), sd = 0.05)
dose = rep(rep(c(1:5), each = 3), 2)
dose
class = rep(c("A", "B"), each = 2)
length(resp)
length(class)
class = rep(c("A", "B"), each = 15)
sprintf("{resp: %f, dose: %d, class: %s}", resp, dose, class)
paste(sprintf("{resp: %f, dose: %d, class: %s},", resp, dose, class), collapse = "\n")
cat(paste(sprintf("{resp: %f, dose: %d, class: %s},", resp, dose, class), collapse = "\n"))
resp = rnorm(30, mean = rep(c(0.1, 0.12, 0.3, 0.8, 0.9, 0.1, 0.1, 0.2, 0.5, 0.9), each = 3), sd = 0.05)
cat(paste(sprintf("{resp: %f, dose: %d, class: '%s'},", resp, dose, class), collapse = "\n"))
library(reshape)
?cast.data.frame
?cast
#
no <- 100#
dd <- data.frame(xv=c(rnorm(no),rnorm(no,0,300) ), set=c(rep(1,no), rep(2,no)))#
#
pdf("over.pdf", width=3.2,height=2.0)#
ggplot(data=dd, aes(xv)) + geom_density() + facet_grid(.~set, scales="free_x")#
dev.off()
 ggplot(data=dd, aes(xv)) + geom_density() + facet_grid(.~set, scales="free_x")
library(pheatmap)
?pheatmap
matrix(runif(10000), 100, 100)
a = matrix(runif(10000), 100, 100)
phatmap(a, legend = F, cluster_cols = F, cluster_rows = F)
pheatmap(a, legend = F, cluster_cols = F, cluster_rows = F)
pheatmap(a, legend = F, cluster_cols = F, cluster_rows = F, border_color = NA)
melt(a)
b = melt(a)
qplot(data = b)
head(b)
qplot(X1, X2, value, geom = "tile", data = b)
?geom_tile
qplot(X1, X2, fill = value, geom = "tile", data = b)
qplot(X1, X2, fill = value, geom = "tile", data = b) + theme_bw()
qplot(X1, X2, fill = value, geom = "tile", data = b) + geom_abline(x = 0.1, slope = 0.7) + theme_bw()
scale_continuous
scale_colour_continuous
?scale_colour_continuous
?scale_colour_discrete
?scale_colour_manual
qplot(X1, X2, fill = value, geom = "tile", data = b) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue") + theme_bw()
qplot(X1, X2, fill = value, geom = "tile", data = b) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw()
qplot(X1, X2, fill = value, geom = "tile", data = b, xlab = "blah") + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw()
qplot(X1, X2, fill = value, geom = "tile", data = b, xlab = expresion("blah")) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw()
qplot(X1, X2, fill = value, geom = "tile", data = b, xlab = expression("blah")) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw()
qplot(X1, X2, fill = value, geom = "tile", data = b, xlab = expression(beta +frac(miles, gallon)))) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw()
qplot(X1, X2, fill = value, geom = "tile", data = b) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw() + xlab(expressionbeta +frac(miles, gallon)))
qplot(X1, X2, fill = value, geom = "tile", data = b) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw() + xlab(expression(beta +frac(miles, gallon)))
?expression
qplot(X1, X2, fill = value, geom = "tile", data = b) + geom_abline(x = 0.1, slope = 0.7) + scale_fill_gradient2(low = "red", mid = "green", high = "blue", midpoint = 0.5) + theme_bw() + xlab(expression(beta_i +frac(miles, gallon)))
?plotmath
ggplot() + stat_function(dnorm)
ggplot() + stat_function(fun = "dnorm")
?stat_function
ggplot() + stat_function(fun = dnorm)
ggplot(xlim = c(-4, 4)) + stat_function(fun = dnorm)
qgplot(xlim = c(-4, 4)) + stat_function(fun = dnorm)
gplot(1, 1, xlim = c(-4, 4)) + stat_function(fun = dnorm)
qplot(1, 1, xlim = c(-4, 4)) + stat_function(fun = dnorm)
qplot(xlim = c(-4, 4)) + stat_function(fun = dnorm)
ggplot() + scale_x_continuous(limits = c(-4,4))
ggplot() + scale_x_continuous(limits = c(-4,4)) + stat_function(fun = dnorm)
x = seq(-10, 10, 0.01)
y = dnorm(x)
qplot(x, y, geom = "area")
qplot(x, y, geom = "area", alpha = 0.5, fill = "blue")
qplot(x, y, geom = "area", alpha = 0.5, fill = I("blue"))
qplot(x, y, geom = "area", alpha = 0.5, fill = I("blue")) + stat_function(fun = dnorm, mean = 2, geom = "area")
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, mean = 2, geom = "area")
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, mean = 2)
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, args = list(mean = 2))
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, geom = "area", args = list(mean = 2))
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, geom = "area", fill = ""green", args = list(mean = 3, sd = 2))
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, geom = "area", fill = "green", args = list(mean = 3, sd = 2))
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, geom = "area", fill = "green", alpha = I(0.5), args = list(mean = 3, sd = 2))
qplot(x, y, geom = "area", alpha = I(0.5), fill = I("blue")) + stat_function(fun = dnorm, geom = "area", fill = "green", alpha = I(0.5), args = list(mean = 3, sd = 2)) + theme_bw()
#
theme_bw_raivo = function(base_size = 12, base_family = ""){#
    structure(list(axis.line = theme_blank(), axis.text.x = theme_text(family = base_family, #
        size = base_size * 0.8, lineheight = 0.9, vjust = 1), #
        axis.text.y = theme_text(family = base_family, size = base_size * #
            0.8, lineheight = 0.9, hjust = 1), axis.ticks = theme_segment(colour = "black", #
            size = 0.2), axis.title.x = theme_text(family = base_family, #
            size = base_size, vjust = 1), axis.title.y = theme_text(family = base_family, #
            size = base_size, angle = 90, vjust = 0.5), axis.ticks.length = unit(0.3, #
            "lines"), axis.ticks.margin = unit(0, "lines"), #
        legend.background = theme_rect(colour = NA), legend.key = theme_rect(colour = "grey80"), #
        legend.key.size = unit(1.2, "lines"), legend.key.height = NA, #
        legend.key.width = NA, legend.text = theme_text(family = base_family, #
            size = base_size * 0.8), legend.text.align = NA, #
        legend.title = theme_text(family = base_family, size = base_size * #
            0.8, face = "bold", hjust = 0), legend.title.align = NA, #
        legend.position = "right", legend.direction = "vertical", #
        legend.box = NA, panel.background = theme_rect(fill = "white", #
            colour = NA), panel.border = theme_rect(fill = NA, #
            colour = "grey50"), panel.grid.major = theme_line(colour = "grey90", #
            size = 0.2), panel.grid.minor = theme_line(colour = "grey98", #
            size = 0.5), panel.margin = unit(0.25, "lines"), #
        strip.background = theme_rect(fill = "grey80", colour = "grey50"), #
        strip.text.x = theme_text(family = base_family, size = base_size * #
            0.8), strip.text.y = theme_text(family = base_family, #
            size = base_size * 0.8, angle = -90), plot.background = theme_rect(colour = NA), #
        plot.title = theme_text(family = base_family, size = base_size * #
            1.2), plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")), #
        class = "options")#
}
library(ggplot2)
plot(1, 1, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw()
qplot(1, 1, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw()
qplot(1, 1, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw_raivo()
#
theme_bw_raivo = function(base_size = 12, base_family = ""){#
    structure(list(axis.line = theme_blank(), axis.text.x = theme_text(family = base_family, #
        size = base_size * 0.8, lineheight = 0.9, vjust = 1), #
        axis.text.y = theme_text(family = base_family, size = base_size * #
            0.8, lineheight = 0.9, hjust = 1), axis.ticks = theme_segment(colour = "black", #
            size = 0.2), axis.title.x = theme_text(family = base_family, #
            size = base_size, vjust = 1), axis.title.y = theme_text(family = base_family, #
            size = base_size, angle = 90, vjust = 0.5), axis.ticks.length = unit(0.3, #
            "lines"), axis.ticks.margin = unit(0.1, "lines"), #
        legend.background = theme_rect(colour = NA), legend.key = theme_rect(colour = "grey80"), #
        legend.key.size = unit(1.2, "lines"), legend.key.height = NA, #
        legend.key.width = NA, legend.text = theme_text(family = base_family, #
            size = base_size * 0.8), legend.text.align = NA, #
        legend.title = theme_text(family = base_family, size = base_size * #
            0.8, face = "bold", hjust = 0), legend.title.align = NA, #
        legend.position = "right", legend.direction = "vertical", #
        legend.box = NA, panel.background = theme_rect(fill = "white", #
            colour = NA), panel.border = theme_rect(fill = NA, #
            colour = "grey50"), panel.grid.major = theme_line(colour = "grey90", #
            size = 0.2), panel.grid.minor = theme_line(colour = "grey98", #
            size = 0.5), panel.margin = unit(0.25, "lines"), #
        strip.background = theme_rect(fill = "grey80", colour = "grey50"), #
        strip.text.x = theme_text(family = base_family, size = base_size * #
            0.8), strip.text.y = theme_text(family = base_family, #
            size = base_size * 0.8, angle = -90), plot.background = theme_rect(colour = NA), #
        plot.title = theme_text(family = base_family, size = base_size * #
            1.2), plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")), #
        class = "options")#
}#
#
qplot(1, 1, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw_raivo()
theme_bw_raivo = function(base_size = 12, base_family = ""){#
    structure(list(axis.line = theme_blank(), axis.text.x = theme_text(family = base_family, #
        size = base_size * 0.8, lineheight = 0.9, vjust = 1), #
        axis.text.y = theme_text(family = base_family, size = base_size * #
            0.8, lineheight = 0.9, hjust = 1), axis.ticks = theme_segment(colour = "black", #
            size = 0.2), axis.title.x = theme_text(family = base_family, #
            size = base_size, vjust = 0), axis.title.y = theme_text(family = base_family, #
            size = base_size, angle = 90, vjust = 0.5), axis.ticks.length = unit(0.3, #
            "lines"), axis.ticks.margin = unit(0.1, "lines"), #
        legend.background = theme_rect(colour = NA), legend.key = theme_rect(colour = "grey80"), #
        legend.key.size = unit(1.2, "lines"), legend.key.height = NA, #
        legend.key.width = NA, legend.text = theme_text(family = base_family, #
            size = base_size * 0.8), legend.text.align = NA, #
        legend.title = theme_text(family = base_family, size = base_size * #
            0.8, face = "bold", hjust = 0), legend.title.align = NA, #
        legend.position = "right", legend.direction = "vertical", #
        legend.box = NA, panel.background = theme_rect(fill = "white", #
            colour = NA), panel.border = theme_rect(fill = NA, #
            colour = "grey50"), panel.grid.major = theme_line(colour = "grey90", #
            size = 0.2), panel.grid.minor = theme_line(colour = "grey98", #
            size = 0.5), panel.margin = unit(0.25, "lines"), #
        strip.background = theme_rect(fill = "grey80", colour = "grey50"), #
        strip.text.x = theme_text(family = base_family, size = base_size * #
            0.8), strip.text.y = theme_text(family = base_family, #
            size = base_size * 0.8, angle = -90), plot.background = theme_rect(colour = NA), #
        plot.title = theme_text(family = base_family, size = base_size * #
            1.2), plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")), #
        class = "options")#
}#
#
qplot(1, 1, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw_raivo()
theme_bw_raivo = function(base_size = 12, base_family = ""){#
    structure(list(axis.line = theme_blank(), axis.text.x = theme_text(family = base_family, #
        size = base_size * 0.8, lineheight = 0.9, vjust = 1), #
        axis.text.y = theme_text(family = base_family, size = base_size * #
            0.8, lineheight = 0.9, hjust = 1), axis.ticks = theme_segment(colour = "black", #
            size = 0.2), axis.title.x = theme_text(family = base_family, #
            size = base_size, vjust = 0.9), axis.title.y = theme_text(family = base_family, #
            size = base_size, angle = 90, vjust = 0.5), axis.ticks.length = unit(0.3, #
            "lines"), axis.ticks.margin = unit(0.1, "lines"), #
        legend.background = theme_rect(colour = NA), legend.key = theme_rect(colour = "grey80"), #
        legend.key.size = unit(1.2, "lines"), legend.key.height = NA, #
        legend.key.width = NA, legend.text = theme_text(family = base_family, #
            size = base_size * 0.8), legend.text.align = NA, #
        legend.title = theme_text(family = base_family, size = base_size * #
            0.8, face = "bold", hjust = 0), legend.title.align = NA, #
        legend.position = "right", legend.direction = "vertical", #
        legend.box = NA, panel.background = theme_rect(fill = "white", #
            colour = NA), panel.border = theme_rect(fill = NA, #
            colour = "grey50"), panel.grid.major = theme_line(colour = "grey90", #
            size = 0.2), panel.grid.minor = theme_line(colour = "grey98", #
            size = 0.5), panel.margin = unit(0.25, "lines"), #
        strip.background = theme_rect(fill = "grey80", colour = "grey50"), #
        strip.text.x = theme_text(family = base_family, size = base_size * #
            0.8), strip.text.y = theme_text(family = base_family, #
            size = base_size * 0.8, angle = -90), plot.background = theme_rect(colour = NA), #
        plot.title = theme_text(family = base_family, size = base_size * #
            1.2), plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")), #
        class = "options")#
}#
#
qplot(1, 1, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw_raivo()
theme_bw_raivo = function(base_size = 12, base_family = ""){#
    structure(list(axis.line = theme_blank(), axis.text.x = theme_text(family = base_family, #
        size = base_size * 0.8, lineheight = 0.9, vjust = 1), #
        axis.text.y = theme_text(family = base_family, size = base_size * #
            0.8, lineheight = 0.9, hjust = 1), axis.ticks = theme_segment(colour = "black", #
            size = 0.2), axis.title.x = theme_text(family = base_family, #
            size = base_size, vjust = 0.7), axis.title.y = theme_text(family = base_family, #
            size = base_size, angle = 90, vjust = 0.5), axis.ticks.length = unit(0.3, #
            "lines"), axis.ticks.margin = unit(0.1, "lines"), #
        legend.background = theme_rect(colour = NA), legend.key = theme_rect(colour = "grey80"), #
        legend.key.size = unit(1.2, "lines"), legend.key.height = NA, #
        legend.key.width = NA, legend.text = theme_text(family = base_family, #
            size = base_size * 0.8), legend.text.align = NA, #
        legend.title = theme_text(family = base_family, size = base_size * #
            0.8, face = "bold", hjust = 0), legend.title.align = NA, #
        legend.position = "right", legend.direction = "vertical", #
        legend.box = NA, panel.background = theme_rect(fill = "white", #
            colour = NA), panel.border = theme_rect(fill = NA, #
            colour = "grey50"), panel.grid.major = theme_line(colour = "grey90", #
            size = 0.2), panel.grid.minor = theme_line(colour = "grey98", #
            size = 0.5), panel.margin = unit(0.25, "lines"), #
        strip.background = theme_rect(fill = "grey80", colour = "grey50"), #
        strip.text.x = theme_text(family = base_family, size = base_size * #
            0.8), strip.text.y = theme_text(family = base_family, #
            size = base_size * 0.8, angle = -90), plot.background = theme_rect(colour = NA), #
        plot.title = theme_text(family = base_family, size = base_size * #
            1.2), plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")), #
        class = "options")#
}#
#
qplot(1, 1, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw_raivo()
qplot(1:10, 1:10, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw_raivo()
theme_bw_raivo = function(base_size = 12, base_family = ""){#
    structure(list(axis.line = theme_blank(), axis.text.x = theme_text(family = base_family, #
        size = base_size * 0.8, lineheight = 0.9, vjust = 1), #
        axis.text.y = theme_text(family = base_family, size = base_size * #
            0.8, lineheight = 0.9, hjust = 1), axis.ticks = theme_segment(colour = "black", #
            size = 0.2), axis.title.x = theme_text(family = base_family, #
            size = base_size, vjust = 0.5), axis.title.y = theme_text(family = base_family, #
            size = base_size, angle = 90, vjust = 0.5), axis.ticks.length = unit(0.3, #
            "lines"), axis.ticks.margin = unit(0.1, "lines"), #
        legend.background = theme_rect(colour = NA), legend.key = theme_rect(colour = "grey80"), #
        legend.key.size = unit(1.2, "lines"), legend.key.height = NA, #
        legend.key.width = NA, legend.text = theme_text(family = base_family, #
            size = base_size * 0.8), legend.text.align = NA, #
        legend.title = theme_text(family = base_family, size = base_size * #
            0.8, face = "bold", hjust = 0), legend.title.align = NA, #
        legend.position = "right", legend.direction = "vertical", #
        legend.box = NA, panel.background = theme_rect(fill = "white", #
            colour = NA), panel.border = theme_rect(fill = NA, #
            colour = "grey50"), panel.grid.major = theme_line(colour = "grey90", #
            size = 0.2), panel.grid.minor = theme_line(colour = "grey98", #
            size = 0.5), panel.margin = unit(0.25, "lines"), #
        strip.background = theme_rect(fill = "grey80", colour = "grey50"), #
        strip.text.x = theme_text(family = base_family, size = base_size * #
            0.8), strip.text.y = theme_text(family = base_family, #
            size = base_size * 0.8, angle = -90), plot.background = theme_rect(colour = NA), #
        plot.title = theme_text(family = base_family, size = base_size * #
            1.2), plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")), #
        class = "options")#
}#
#
qplot(1:10, 1:10, xlab = "baasdfasfasdfasdfasdfasdfasdf") + theme_bw_raivo()
library(roxygen)#
#
setwd("~/Raivo/Projects/RUtil/")#
#
roxygenize(package.dir = "Source", roxygen.dir = "RUtil", unlink.target = T, use.Rd2 = T)
